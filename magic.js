`https://learn.javascript.ru/array-methods#preobrazovanie-massiva`

// -------------------------------------------------------------------------------

`arr.filter`
// Метод find ищет один (первый) элемент, который заставит функцию вернуть true.
// Если найденных элементов может быть много, можно использовать arr.filter(fn).
// Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов:

let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2

// -------------------------------------------------------------------------------

`arr.map`
// Метод arr.map является одним из наиболее полезных и часто используемых.
// Он вызывает функцию для каждого элемента массива и возвращает массив
// результатов выполнения этой функции.
let arr1 = ["Бильбо", "Гэндальф", "Назгул"];
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});

// Например, здесь мы преобразуем каждый элемент в его длину:
let lengths = arr1.map(item => item.length);
alert(lengths); // 6,8,6

// -------------------------------------------------------------------------------

`sort(fn)`
// Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
// Он также возвращает отсортированный массив, но обычно возвращаемое значение игнорируется,
// так как изменяется сам arr.

// По умолчанию элементы сортируются как строки.
// Буквально, элементы преобразуются в строки при сравнении.
// Для строк применяется лексикографический порядок,
// и действительно выходит, что "2" > "15".


let arr2 = [ 1, 2, 15 ];
arr2.sort();
alert( arr2 );  // 1, 15, 2

// Чтобы использовать наш собственный порядок сортировки,
// нам нужно предоставить функцию в качестве аргумента arr.sort().
// Функция должна для пары значений возвращать:

function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}

// Например, для сортировки чисел:

let arr3 = [ 1, 2, 15 ];
arr3.sort(compare);
alert(arr3);  // 1, 2, 15

// Лучше использовать стрелочные фнункции.
// Будет работать точно так же, как и более длинная версия выше:
arr3.sort( (a, b) => a > b ? 1 : -1);
arr3.sort( (a, b) => a - b );

// Используйте localeCompare для строк:
let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)

// -------------------------------------------------------------------------------

`reverse`
// Метод arr.reverse меняет порядок элементов в arr на обратный.

let arr4 = [1, 2, 3, 4, 5];
arr4.reverse();
alert( arr4 ); // 5,4,3,2,1

// -------------------------------------------------------------------------------

`split и join`

// Метод str.split(delim) именно это и делает. Он разбивает строку на массив по
// заданному разделителю delim.
// В примере ниже таким разделителем является строка из запятой и пробела.

let names = 'Вася, Петя, Маша';
let arr5 = names.split(', ');
for (let name of arr5) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}
// У метода split есть необязательный второй числовой аргумент – ограничение
// на количество элементов в массиве. Если их больше, чем указано,
// то остаток массива будет отброшен. На практике это редко используется:

let arr6 = 'Вася, Петя, Маша, Саша'.split(', ', 2);
alert(arr6); // Вася, Петя

// Вызов arr.join(glue) делает в точности противоположное split.
// Он создаёт строку из элементов arr, вставляя glue между ними.

let arr7 = ['Вася', 'Петя', 'Маша'];
let str = arr7.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша

// -------------------------------------------------------------------------------

`reduce/reduceRight`
// Когда нам нужно перебрать массив – мы можем использовать
// forEach, for или for..of.
// Когда нам нужно перебрать массив и вернуть данные для каждого
// элемента – мы можем использовать map.
// Методы arr.reduce и arr.reduceRight похожи на методы выше,
// но они немного сложнее. Они используются для вычисления единого
// значения на основе всего массива.

let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);

// Функция применяется по очереди ко всем элементам
// массива и «переносит» свой результат на следующий вызов.

// Аргументы:

`accumulator` //– результат предыдущего вызова этой функции,
              // равен initial при первом вызове (если передан initial),
`item` //– очередной элемент массива,
`index` //– его позиция,
`array` //– сам массив.

// При вызове функции результат её предыдущего вызова передаётся на
// следующий вызов в качестве первого аргумента.
// Так, первый аргумент является по сути аккумулятором, который хранит
// объединённый результат всех предыдущих вызовов функции.
// По окончании он становится результатом reduce.

// Функция, переданная в reduce, использует только два аргумента,
// этого обычно достаточно.

let arr = [1, 2, 3, 4, 5];

let result1 = arr.reduce((sum, current) => sum + current, 0);
// или
// убрано начальное значение (нет 0 в конце)
`let result1 = arr.reduce((sum, current) => sum + current);`
`alert( result1 ); // 15`
// Результат – точно такой же! Это потому, что при отсутствии initial
// в качестве первого значения берётся первый элемент массива,
// а перебор стартует со второго.
`Но такое использование требует крайней осторожности.
Если массив пуст, то вызов reduce без начального значения выдаст ошибку.
Поэтому рекомендуется всегда указывать начальное значение.`

// Разберём детально как это работает.
// При первом запуске sum равен initial (последний аргумент reduce),
    // то есть 0, а current – первый элемент массива, равный 1.
    // Таким образом, результат функции равен 1.
// При втором запуске sum = 1, к нему мы добавляем второй элемент
    // массива (2) и возвращаем.
// При третьем запуске sum = 3, к которому мы добавляем следующий
    // элемент, и так далее…

// -------------------------------------------------------------------------------

`Array.isArray`
// Массивы не образуют отдельный тип языка. Они основаны на объектах.
// Поэтому typeof не может отличить простой объект от массива:

alert(typeof {}); // object
alert(typeof []); // тоже object
// …Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value). Он возвращает true, если value массив, и false, если нет.

alert(Array.isArray({})); // false
alert(Array.isArray([])); // true

// -------------------------------------------------------------------------------

`Итоги - Шпаргалка по методам массива:`

`Для добавления/удаления элементов:`

push(...items) //– добавляет элементы в конец,
pop() //– извлекает элемент с конца,
shift() //– извлекает элемент с начала,
unshift(...items) //– добавляет элементы в начало.
splice(pos, deleteCount, ...items) //– начиная с индекса pos удаляет deleteCount элементов и вставляет items.
slice(start, end) //– создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
concat(...items) //– возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

`Для поиска среди элементов:`

indexOf/lastIndexOf(item, pos) //– ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
includes(value) //– возвращает true, если в массиве имеется элемент value, в противном случае false.
find/filter(func) //– фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.
let idRowSearch = rows.value.findIndex(e => e.idRow === i)

`Для перебора элементов:`

forEach(func) //– вызывает func для каждого элемента. Ничего не возвращает.

`Для преобразования массива:`

map(func) //– создаёт новый массив из результатов вызова func для каждого элемента.
sort(func) //– сортирует массив «на месте», а потом возвращает его.
reverse() //– «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
split/join //– преобразует строку в массив и обратно.
reduce/reduceRight(func, initial) //– вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

`Дополнительно:`

Array.isArray(arr) //- проверяет, является ли arr массивом.
`Пожалуйста, обратите внимание, что методы `
  push,
  pop,
  shift,
  unshift,
  sort,
  reverse,
  splice
  `изменяют исходный массив.`

// -------------------------------------------------------------------------------

`Сравнение совпадений из разных списков (arr.some arr.every )`

  // Работа с объектами
let data = [
  {"title" : "фильм1", "tags" : ["драма", "мистика"]},
  {"title" : "фильм2", "tags" : ["драма", "боевик", "бубу"]},
  {"title" : "фильм3", "tags" : ["ужасы", "боевик"]}
];

let selectedTags = ["ужасы", "бубу"];

let result2 = data.filter( ({tags: arr}) => arr.some( tag => selectedTags.includes(tag) ) );
console.table( result2 );
// или
let result3 = data.filter( movie => movie.tags.some( tag => selectedTags.includes(tag) ) );
console.table( result3 );
// или
let result4 = data.filter( movie => selectedTags.some( tag => movie.tags.includes(tag) ) );
console.table( result4 );


// Работа с вложенными списками
let selectedTags1 = ["ужасы", "бубу"];
let data2 = [["драма", "мистика"], ["драма", "боевик", "бубу"], ["ужасы", "боевик"]]

// Находим совпадение хотябы одного вложенного списка с искомым списком
remark = data2.value.some(arr => arr.every(tag =>  selectedTags1.includes(tag)))

// Находим вложенные списки, значения, которых совпадают с любым значением из списка selectedTags
let result5 = data2.filter( arr => arr.some( tag => selectedTags1.includes(tag)));
console.table( result5 );

// А для строгой фильтрации:
let result6 = data2.filter( arr => selectedTags1.every( tag => arr.tags.includes(tag)) );
console.log( result6 );

// Находим нидексы найденных списков
let result7 = data2.filter( arr => arr.some( tag => selectedTags1.includes(tag))).map(e => data2.indexOf(e) );
console.table( result7 );

// Булевый результат сравнения
let result8 = arr.some(tag => selectedTags1.includes(tag));

// -------------------------------------------------------------------------------
// Замена символов в строке
let result9 = text.replace("Microsoft", "W3Schools");
// -------------------------------------------------------------------------------
// Объект из повторяющихся значений и их количества из списка
function arrayCountValues (arr) {
  var v, freqs = {};
  for (var i = arr.length; i--; ) {
    v = arr[i];
    if (freqs[v]) freqs[v] += 1;
    else freqs[v] = 1;
  }
  return freqs;
}
// -------------------------------------------------------------------------------
// Объект из повторяющихся свойств из списка объектов
const computedColsFamili = computed(() => {
  let obj = {}
  let arr = []
  let parents = Object.keys(computedColsParents.value)
  parents.map(e => {
    arr = []
    headers.value.forEach((col, i) => {
      if(e === col.mergeParentName && visibleColumns.value.includes(col.name)){
        arr = [...arr, col.name]
        obj[col.mergeParentName] = [...arr]
      }
    })
  })
  return obj
})
// -------------------------------------------------------------------------------
