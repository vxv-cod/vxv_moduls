'''https://docs-python.ru/packages/modul-python-docx-python/'''

'''# Открытие/создание документа'''
from docx import Document

# создание документа
document = Document()
# открытие документа
document = Document('/path/to/document.docx')
# document = Document('ShablonTZII.docx')

# При этом шрифт документа и его размер по умолчанию для всего документа можно задать следующим образом:
from docx import Document
from docx.shared import Pt

doc = Document()
# задаем стиль текста по умолчанию
style = doc.styles['Normal']
# название шрифта
style.font.name = 'Arial'
# размер шрифта
style.font.size = Pt(14)
document.add_paragraph('Текст документа')

'''# Добавление заголовка документа.'''
# В любом документе, основной текст делится на разделы, каждый из которых начинается с заголовка. 
# Название таких разделов можно добавить методом Document.add_heading():
# без указания аргумента `level` 
# добавляется заголовок "Heading 1"
head = document.add_heading('Основы работы с файлами Microsoft Word на Python.')
from docx.enum.text import WD_ALIGN_PARAGRAPH
# выравнивание посередине
head.alignment = WD_ALIGN_PARAGRAPH.CENTER

# По умолчанию, добавляется заголовок верхнего уровня, который отображается в Word как "Heading 1". Если нужен заголовок для подраздела, то просто указываем желаемый уровень в виде целого числа от 1 до 9:
# document.add_heading('Добавление заголовка документа', level=2)
# Если указать level=0, то будет добавлен текст с встроенным стилем титульной страницы. 
# Такой стиль может быть полезен для заголовка относительно короткого документа без отдельной титульной страницы.
# Так же, заголовки разделов можно добавлять методом document.add_paragraph().add_run(), с указанным размером шрифта.
# Например:
from docx import Document
from docx.shared import Pt

doc = Document()
# добавляем текст прогоном
run = doc.add_paragraph().add_run('Заголовок, размером 24 pt.')
# размер шрифта
run.font.size = Pt(24)
run.bold = True
doc.save('test.docx')

'''# Добавление абзаца.'''
# Абзацы в Word имеют основополагающее значение. Они используются для добавления колонтитулов, основного текста, заголовков, элементов списков, картинок и т.д.
# Смотрим самый простой способ добавить абзац/параграф:
p = document.add_paragraph('Абзацы в Word имеют основополагающее значение.')
# Метод Document.add_paragraph() возвращает ссылку на только что добавленный абзац (объект Paragraph). 
# Абзац добавляется в конец документа. Эту ссылку можно использовать в качестве своеобразного "курсора" и 
# например, вставить новый абзац прямо над ним:
prior_p = p.insert_paragraph_before(
          'Объект `paragraph` - это ссылка на только что добавленный абзац.')
# Такое поведение позволяет вставить абзац в середину документа, 
# это важно при изменении существующего документа, а не при его создании с нуля.
# Ссылка на абзац, так же используется для его форматирования встроенными в MS Word 
# стилями или для кастомного/пользовательского форматирования.

'''
# {Пользовательское форматирование абзаца}.
# Форматирование абзацев происходит при помощи объекта {ParagraphFormat}.
# Пример и синтаксис объекта {ParagraphFormat}:
# Пример использования объекта форматирования абзаца {ParagraphFormat} документа MS Word.
'''
import docx
from docx.shared import Mm
from docx.enum.text import WD_ALIGN_PARAGRAPH

# создание документа
doc = docx.Document()
# Добавляем абзац
p = doc.add_paragraph('Новый абзац.')
# выравниваем абзац по центру
p.alignment = WD_ALIGN_PARAGRAPH.CENTER
# получаем объект форматирования
fmt = p.paragraph_format
# Форматируем:
# отступ слева в мм
fmt.first_line_indent = Mm(15)
# отступ сверху в мм 
fmt.space_before = Mm(20)
# отступ снизу в мм
fmt.space_after = Mm(10)
doc.add_paragraph('Еще новый абзац.')

# а вот так можно получить значения 
# в нужных единицах измерения
print('Интервал перед абзацем в сантиметрах:')
print('    - в сантиметрах:', fmt.space_before.cm)
space_before_mm = fmt.space_before.mm
print('    - в миллиметрах:', fmt.space_before.mm)
doc.save('test.docx')
'''
# Описание объекта {ParagraphFormat}.
# Объект {ParagraphFormat} модуля python-docx предоставляет доступ к форматированию абзацев документа MS Word, 
# например выравниванию, отступу, межстрочному интервалу, пробелам до и после, отступу первого предложения абзаца 
# ("Красная строка") и т.д.
# Объект {ParagraphFormat} НЕ создается вручную, а возвращается свойством абзаца/параграфа Paragraph.paragraph_format.
# Свойства объекта {ParagraphFormat}.
# Эти свойства доступны как для чтения, так и для установки/присваивания им значений, если не указано иное.
'''
'''
{ParagraphFormat.alignment}           выравнивания абзаца,
{ParagraphFormat.first_line_indent}   отступ первой строки абзаца,
{ParagraphFormat.keep_together}       не разрывать абзац,
{ParagraphFormat.keep_with_next}      сохранить следующий абзац на этой странице,
{ParagraphFormat.left_indent}         расстояние между левым полем и левой стороной абзаца,
{ParagraphFormat.line_spacing}        межстрочный интервал,
{ParagraphFormat.line_spacing_rule}   правила расчета межстрочного интервала,
{ParagraphFormat.page_break_before}   абзац вверху страницы после предыдущего абзаца,
{ParagraphFormat.right_indent}        расстояние между правым полем и правой стороной абзаца,
{ParagraphFormat.space_after}         интервал между этим и следующим абзацем,
{ParagraphFormat.space_before}        интервал между этим и предыдущим абзацем,
{ParagraphFormat.tab_stops}           доступ к позициям табуляции,
{ParagraphFormat.widow_control}       первая и последняя строки в абзаце на той же странице.
'''
'''
{ParagraphFormat.alignment}:
# Свойство ParagraphFormat.alignment представляет собой член перечисления WD_PARAGRAPH_ALIGNMENT, 
# определяющий настройку выравнивания для этого абзаца. Значение None указывает, 
# что выравнивание абзаца унаследовано от иерархии стилей.
'''
'''
{ParagraphFormat.alignment:WD_PARAGRAPH_ALIGNMENT}:
Короткая ссылка для импорта {WD_ALIGN_PARAGRAPH} - это перечисление, которое задает тип выравнивание всего текста в абзаце/параграфе.
{WD_ALIGN_PARAGRAPH.LEFT} - по левому краю;
{WD_ALIGN_PARAGRAPH.CENTER} - по центру;
{WD_ALIGN_PARAGRAPH.RIGHT} - по правому краю;
{WD_ALIGN_PARAGRAPH.JUSTIFY} - по ширине;
{WD_ALIGN_PARAGRAPH.DISTRIBUTE} - символы распределяются так, чтобы заполнить всю ширину абзаца;
{WD_ALIGN_PARAGRAPH.JUSTIFY_MED} - оправдано со средней степенью сжатия символов;
{WD_ALIGN_PARAGRAPH.JUSTIFY_HI} - оправдано высокой степенью сжатия символов;
{WD_ALIGN_PARAGRAPH.JUSTIFY_LOW} - оправдано с низким коэффициентом сжатия символов.
Пример:
'''
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx import Document

paragraph = document.add_paragraph()
paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER

'''
{ParagraphFormat.first_line_indent}:
# Свойство {ParagraphFormat.first_line_indent} возвращает/принимает значение {Length}, 
# которое определяет относительную разницу в отступах для первой строки абзаца.
# Положительное значение приводит к отступу первой строки абзаца.
# Отрицательное значение создает выступ.
# Значение None означает, что отступ первой строки унаследован от иерархии стилей.

# Объекты длинны Length ведет себя как целое число int английских метрических единиц: 
# 914400 в дюймах, 36000 в мм. Предоставляет собой удобные методы преобразования единиц 
# измерения в виде свойств, доступных только для чтения.

{length_object.mm}: эквивалентная длина, выраженная в миллиметрах.
{length_object.cm}: эквивалентная длина, выраженная в сантиметрах.
{length_object.pt}: длина, выраженная в пунктах
{length_object.inches}: эквивалентная длина, выраженная в дюймах.
{length_object.emu}: эквивалентная длина, выраженная в английских метрических единицах.
{length_object.twips}: эквивалентная длина, выраженная в твипах.
'''
'''# Пример чтения значений объекта Length в нужных единицах:'''
from docx import Document
# создаем пустой документ 
doc = Document()
# смотрим ширину документа 
# в собственных единицах 
doc.sections[0].page_width
# 7772400
# ширина документа в миллиметрах
doc.sections[0].page_width.mm
# 215.9
# ширина документа в сантиметрах
doc.sections[0].page_width.cm
# 21.59

'''# Пример установки значений объекта Length в нужных единицах:'''
from docx import Document
# импортируем классы единиц измерений
from docx.shared import Mm, Cm
# новый документ 
doc = Document()
# устанавливаем ширину в миллиметрах
doc.sections[0].page_width = Mm(150)
# смотрим что получилось
doc.sections[0].page_width.mm
# 150.0011
doc.sections[0].page_width.cm
# 15.00011

'''
{ParagraphFormat.keep_together}:
# Свойство ParagraphFormat.keep_together возвращает (или присвоить) True, если абзац необходимо сохранить "цельным", 
# а не разрывать его на границе страницы при визуализации документа. Значение None означает, что его действующее значение унаследовано от иерархии стилей.

{ParagraphFormat.keep_with_next}:
# Свойство ParagraphFormat.keep_with_next возвращает (или присвоить) True, если абзац должен 
# быть сохранен на той же странице, что и следующий абзац при отображении документа.
# Например, это свойство можно использовать для сохранения заголовка раздела на той же странице, 
# что и его первый абзац. Ни один из них не указывает на то, что его эффективное значение унаследовано от иерархии стилей.

{ParagraphFormat.left_indent}:
# Свойство ParagraphFormat.left_indent возвращает/принимает значение Length, которое определяет расстояние 
# между левым полем и левой стороной абзаца. Значение None означает, что отступа слева унаследован от иерархии стилей.
# Используйте объект значения Mm() как удобный способ установить отступ в миллиметрах.

{ParagraphFormat.line_spacing}:
# Свойство ParagraphFormat.line_spacing значение float или Length, определяющее расстояние между 
# базовыми линиями в последовательных строках абзаца. Другими словами, межстрочный интервал.
# Значение None указывает, что межстрочный интервал унаследован от иерархии стилей.Значение с 
# плавающей запятой, например 2.0 или 1.75, указывает, что интервал применяется кратно высоте строки.
# Значение длины Length, такое как Pt(12), указывает, что интервал является фиксированной высотой в пунктах.
# Класс значений Pt() - это удобный способ применения межстрочного интервала в пунктах.

{ParagraphFormat.line_spacing_rule}:
# Свойство ParagraphFormat.line_spacing_rule представляет собой член перечисления WD_LINE_SPACING, 
# указывающий, как следует интерпретировать значение межстрочного интервала. Назначение любого из членов SINGLE, 
# DOUBLE или ONE_POINT_FIVE приведет к обновлению наследуемого значения межстрочного интервала.

{WD_LINE_SPACING}:
# Перечисление {WD_LINE_SPACING} задает формат межстрочного интервала, 
# применяемый к объекту форматирования абзаца {ParagraphFormat.line_spacing_rule}
# Устанавливаемые значения:
# {WD_LINE_SPACING.ONE_POINT_FIVE} - Space-and-a-half line spacing.
# {WD_LINE_SPACING.AT_LEAST} - межстрочный интервал всегда должен быть не менее указанного значения;
# {WD_LINE_SPACING.DOUBLE} - двойной межстрочный интервал;
# {WD_LINE_SPACING.EXACTLY} - межстрочный интервал - это точно указанная величина;
# {WD_LINE_SPACING.MULTIPLE} - межстрочный интервал указывается как кратный высоте строки. Изменение размера шрифта пропорционально изменит межстрочный интервал;
# {WD_LINE_SPACING.SINGLE} - одинарный межстрочный интервал (по умолчанию).
# Пример:
'''
from docx.enum.text import WD_LINE_SPACING
paragraph = document.add_paragraph()
paragraph.paragraph_format.line_spacing_rule = WD_LINE_SPACING.EXACTLY

'''
{ParagraphFormat.page_break_before}:
# Свойство ParagraphFormat.page_break_before возвращает (или присвоить) True, если абзац должен появиться вверху 
# страницы после предыдущего абзаца. Значение None означает, что его действующее значение унаследовано от иерархии стилей.

{ParagraphFormat.right_indent}:
# Свойство ParagraphFormat.right_indent возвращает/принимает значение Length, которое определяет расстояние между 
# правым полем и правой стороной абзаца. Значение None означает, что значение отступа справа унаследовано от иерархии стилей.
# Используйте объект значения Cm, как удобный способ установить отступ в сантиметрах.

{ParagraphFormat.space_after}:
# Свойство ParagraphFormat.space_after возвращает/принимает значение Length, которое определяет интервал между 
# этим и последующим абзацами. Значение None означает, что это значение унаследовано от иерархии стилей.
# Объект Length предоставляет удобные свойства, такие как .mm и .cm, которые позволяют легко читать значения в различных единицах длины.

{ParagraphFormat.space_before}:
# Свойство ParagraphFormat.space_before возвращает/принимает значение Length, которое определяет интервал между этим и предыдущим абзацами.
# Значение None означает, что это значение унаследовано от иерархии стилей.

{ParagraphFormat.tab_stops}:
# Свойство ParagraphFormat.tab_stops представляет собой объект TabStops, обеспечивающий доступ к позициям табуляции, определенным для этого формата абзаца.

{ParagraphFormat.widow_control}:
# Свойство ParagraphFormat.widow_control возвращает (или присвоить) True, если первая и последняя строки 
# в абзаце остаются на той же странице, что и остальная часть абзаца, когда Word повторно создает документ.
# Значение None означает, что его действующее значение унаследовано от иерархии стилей.
'''

'''Встроенные {константы} модуля python-docx'''
'''https://docs-python.ru/packages/modul-python-docx-python/konstanty-modulja-docx/#WD_LINE_SPACING'''

'''Применение встроенного стиля в Microsoft Word к абзацу.'''
# Стиль абзаца - это набор правил форматирования, который заранее определен в Microsoft Word, 
# и храниться в редакторе в качестве переменной. По сути, стиль позволяет сразу применить к абзацу целый набор параметров форматирования.

# Можно применить стиль абзаца, прямо при его создании:
document.add_paragraph('Стиль абзаца как цитата', style='Intense Quote')
document.add_paragraph('Стиль абзаца как список.', style='List Bullet')
# В конкретном стиле 'List Bullet', абзац отображается в виде маркера. Также можно применить стиль позже. Две строки, в коде ниже, эквивалентны примеру выше:
document.add_paragraph('Другой стиль абзаца.').style = 'List Number'

# Эквивалентно 
paragraph = document.add_paragraph('Другой стиль абзаца.')
# применяем стиль позже
paragraph.style = 'List Number'
# Стиль указывается с использованием его имени, в этом примере имя стиля - 'List'. Как правило, имя стиля точно такое, как оно отображается в пользовательском интерфейсе Word.
# Обратите внимание, что можно установить встроенный стиль прямо на результат document.add_paragraph(), без использования возвращаемого объекта paragraph


'''{Жирный}, {курсив} и {подчеркнутый} текст в абзаце.
# Разберемся, что происходит внутри абзаца:
# Абзац содержит все форматирование на уровне блока, такое как - отступ, высота строки, табуляции и так далее.
# Форматирование на уровне символов, например полужирный и курсив, применяется на уровне прогона paragraph.add_run(). 
# Все содержимое абзаца должно находиться в пределах цикла, но их может быть больше одного. Таким образом, для абзаца 
# с полужирным словом посередине требуется три прогона: обычный, полужирный - содержащий слово, и еще один нормальный для текста после него.
# Когда создается абзац методом Document.add_paragraph(), то передаваемый текст добавляется за один прогон Run. 
# Пустой абзац/параграф можно создать, вызвав этот метод без аргументов. В этом случае, наполнить абзац текстом 
# можно с помощью метода Paragraph.add_run(). Метод абзаца .add_run() можно вызывать несколько раз, тем самым добавляя информацию в конец данного абзаца:
'''
paragraph = document.add_paragraph('Абзац содержит форматирование ')
# тем самым добавляя информацию в конец данного абзаца
paragraph.add_run('на уровне блока.')
'''
В результате получается абзац, который выглядит так же, как абзац, созданный из одной строки. 
Если не смотреть на полученный XML, то не очевидно, где текст абзаца разбивается на части. 
Обратите внимание на конечный пробел в конце первой строки. Необходимо четко указывать, 
где появляются пробелы в начале и в конце прогона, иначе текст будет слитный (без пробелов). 
Они (пробелы) автоматически не вставляются между прогонами paragraph.add_run(). 
Метод paragraph.add_run() возвращает ссылку на объект прогона Run, которую можно использовать, если она нужна.
Объекты прогонов имеют следующие свойства, которые позволяют установить соответствующий стиль:
{.bold:} полужирный текст;
{.underline}: подчеркнутый текст;
{.italic}: курсивный (наклонный) текст;
{.strike}: зачеркнутый текст.
'''
paragraph = document.add_paragraph('Абзац содержит ')
paragraph.add_run('форматирование').bold = True
paragraph.add_run(' на уровне блока.')
# Обратите внимание, что можно установить полужирный или курсив прямо на результат paragraph.add_run(), без использования возвращаемого объекта прогона:
paragraph.add_run('форматирование').bold = True
# или
run = paragraph.add_run('форматирование')
run.bold = True

# Передавать текст в метод Document.add_paragraph() не обязательно. 
# Это может упростить код, если строить абзац из прогонов:
paragraph = document.add_paragraph()
paragraph.add_run('Абзац содержит ')
paragraph.add_run('форматирование').bold = True
paragraph.add_run(' на уровне блока.')


'''# Пользовательское задание шрифта прогона.'''
from docx import Document
from docx.shared import Pt, RGBColor
# создание документа
doc = Document()
# добавляем текст прогоном
run = doc.add_paragraph().add_run('Заголовок, размером 24 pt.')
# название шрифта
run.font.name = 'Arial'
# размер шрифта
run.font.size = Pt(24)
# цвет текста
run.font.color.rgb = RGBColor(0, 0, 255)
# + жирный и подчеркнутый
run.font.bold = True
run.font.underline = True
doc.save('test.docx')


'''Применение стилей Microsoft Word к символам текста (к прогону).'''
# В дополнение к встроенным стилям абзаца, которые определяют группу параметров уровня абзаца, Microsoft Word имеет стили символов, которые определяют группу параметров уровня прогона paragraph.add_run(). Другими словами, можно думать о стиле текста как об указании шрифта, включая его имя, размер, цвет, полужирный, курсив и т. д.
# Подобно стилям абзацев, стиль символов текста будет определен в документе, который открывается с помощью вызова Document() (см. Общие сведения о стилях).
# Стиль символов можно указать при добавлении нового прогона:
paragraph = document.add_paragraph('Обычный текст, ')
paragraph.add_run('текст с акцентом.', 'Emphasis')
# Также можете применить стиль к прогону после его добавления. Этот код дает тот же результат, что и строки выше:
paragraph = document.add_paragraph()
paragraph.add_run('Обычный текст, ')
paragraph.add_run('текст с акцентом.').style = 'Emphasis'
# Как и в случае со стилем абзаца, имя стиля текста такое, как оно отображается в пользовательском интерфейсе Word.


'''Пользовательский стиль символов текста.'''
from docx import Document
from docx.shared import Pt, RGBColor
# создание документа
doc = Document()
# задаем стиль текста по умолчанию
style = doc.styles['Normal']
# название шрифта
style.font.name = 'Calibri'
# размер шрифта
style.font.size = Pt(14)
p = doc.add_paragraph('Пользовательское ')
# добавляем текст прогоном 
run = p.add_run('форматирование ')
# размер шрифта
run.font.size = Pt(16)
# курсив
run.font.italic = True
# добавляем еще текст прогоном
run = p.add_run('символов текста.')
# Форматируем:
# название шрифта
run.font.name = 'Arial'
# размер шрифта
run.font.size = Pt(18)
# цвет текста
run.font.color.rgb = RGBColor(255, 0, 0)
# + жирный и подчеркнутый
run.font.bold = True
run.font.underline = True
doc.save('test.docx')


'''Добавление разрыва страницы.'''
# При создании документа, время от времени нужно, чтобы следующий текст выводился на отдельной странице, 
# даже если последняя не заполнена. Жесткий разрыв страницы можно сделать следующим образом:
document.add_page_break()
# Если вы обнаружите, что используете это очень часто, это, вероятно, знак того, что вы могли бы извлечь выгоду, 
# лучше разбираясь в стилях абзацев. Одно свойство стиля абзаца, которое вы можете установить - 
# это разрыв страницы непосредственно перед каждым абзацем, имеющим этот стиль. Таким образом, вы можете 
# установить заголовки определенного уровня, чтобы всегда начинать новую страницу. Подробнее о стилях позже. 
# Они оказываются критически важными для получения максимальной отдачи от Word.
# Жесткий разрыв страницы можно привязать к стилю абзаца, и затем применять его для определенных абзацев, 
# которые должны начинаться с новой страницы. Так же можно установить жесткий разрыв на стиль заголовка 
# определенного уровня, чтобы с него всегда начинать новую страницу. В общем, стили, оказываются 
# критически важными для того, чтобы получить максимальную отдачу от модуля python-docx.


'''Добавление картинки в документ.'''
# Microsoft Word позволяет разместить изображение в документе с помощью пункта 
# меню "Вставить изображение". Вот как это сделать при помощи модуля python-docx:
document.add_picture('/path/to/image-filename.png')
# В этом примере используется путь, по которому файл изображения загружается из локальной файловой системы. 
# В качестве пути можно использовать файловый объект, по сути, любой объект, который действует как открытый файл. 
# Такое поведение может быть полезно, если изображение извлекается из базы данных или передается по сети.

'''Размер изображения.'''
# По умолчанию, изображение добавляется с исходными размерами, что часто не устраивает пользователя. Собственный размер рассчитывается как px/dpi. Таким образом, изображение размером 300x300 пикселей с разрешением 300 точек на дюйм появляется в квадрате размером один дюйм. Проблема в том, что большинство изображений не содержат свойства dpi, и по умолчанию оно равно 72 dpi. Следовательно, то же изображение будет иметь одну сторону, размером 4,167 дюйма, что означает половину страницы.
# Чтобы получить изображение нужного размера, необходимо указывать его ширину или высоту в удобных единицах измерения, например, в миллиметрах или сантиметрах:
from docx.shared import Mm
document.add_picture('/path/to/image-filename.png', width=Mm(35))

# Если указать только одну из сторон, то модуль python-docx использует его для вычисления правильно масштабированного 
# значения другой стороны изображения. Таким образом сохраняется соотношение сторон и изображение не выглядит растянутым.
# Классы Mm() и Cm() предназначены для того, чтобы можно было указывать размеры в удобных единицах. Внутри python-docx 
# используются английские метрические единицы, 914400 дюймов. Так что, если просто указать размер, что-то вроде width=2, 
# то получится очень маленькое изображение. Классы Mm() и Cm() импортируются из подпакета docx.shared. 
# Эти классы можно использовать в арифметике, как если бы они были целыми числами. Так что выражение, width=Mm(38)/thing_count, работает нормально.


'''Чтение документов Microsoft Word.'''
# В модуле python-docx, структура документа Microsoft Word представлена тремя различными типами данных. 
# На самом верхнем уровне объект Document() представляет собой весь документ. Объект Document() содержит 
# список объектов Paragraph(), которые представляют собой абзацы документа. Каждый из абзацев содержит список, 
# состоящий из одного или нескольких объектов Run(), представляющих собой фрагменты текста с различными стилями форматирования.
# Например:
from docx import Document
doc = Document('/path/to/example.docx')
# количество абзацев в документе
len(doc.paragraphs)
# текст первого абзаца в документе
doc.paragraphs[0].text
# текст второго абзаца в документе
doc.paragraphs[1].text
# текст первого прогона второго абзаца
doc.paragraphs[1].runs[0].text

'''# Используя следующий код, можно получить весь текст документа:'''
text = []
for paragraph in doc.paragraphs:
    text.append(paragraph.text)
print('\n\n'.join(text))

'''А так можно получить стили всех параграфов:'''
styles = []
for paragraph in doc.paragraphs:
    styles.append(paragraph.style)

'''Использовать полученные стили можно следующим образом:'''
# изменим стиль 1 параграфа на 
# стиль взятый из 3 параграфа
doc.paragraphs[0].style = styles[2]



'''https://docs-python.ru/packages/modul-python-docx-python/klass-section/#_Footer'''
'''Класс Section() модуля python-docx в Python.'''

'''# Объект {Section}.'''
# Объект Section не создается вручную и представляет собой раздел документа, обеспечивающий доступ
# к настройкам раздела и макета страницы. Он также обеспечивает доступ к верхним и нижним колонтитулам.
# Объект Section возвращается свойством документа Document.sections[i], где i - это индекс секции/раздела в документе DOCX.

from docx import Document

# создание экземпляра документа
doc = Document()
# получение объекта первой секции:
section1 = doc.sections[0]
# добавление новой секции
doc.add_section()
# получение объекта второй секции:
section2 = doc.sections[1]

# Свойства объекта Section (Раздел).
Section = doc.sections[0]
# нижнее поле для всех страниц,
Section.bottom_margin 
# отдельные верхний и нижний колонтитулы для первой страницы,
Section.different_first_page_header_footer
# нижний колонтитул для четных страниц,
Section.even_page_footer
# верхний колонтитул для четных страниц,
Section.even_page_header
# нижний колонтитула для первой страницы,
Section.first_page_footer
# верхний колонтитула для первой страницы,
Section.first_page_header
# нижний колонтитул страницы по умолчанию,
Section.footer
# расстояние от нижнего края страницы до нижнего края нижнего колонтитула,
Section.footer_distance
# размер желоба страницы,
Section.gutter
# верхний колонтитул страницы по умолчанию,
Section.header
# расстояние от верхнего края страницы до верхнего края верхнего колонтитула,
Section.header_distance
# левое поле для всех страниц,
Section.left_margin
# ориентация страницы,
Section.orientation
# общая высота страницы,
Section.page_height
# общая ширина страницы,
Section.page_width
# правое поле для всех страниц,
Section.right_margin
# поведению начального разрыва раздела,
Section.start_type
# верхнее поле для всех страниц,
Section.top_margin

'''
{Section.bottom_margin}:
# Свойство Section.bottom_margin объект длины Length, представляющий нижнее поле для всех страниц в этом разделе в английских метрических единицах.

{Section.different_first_page_header_footer}:
# Свойство Section.different_first_page_header_footer возвращает True, если в этом разделе отображаются отдельные верхний и нижний колонтитулы для первой страницы . Свойство можно читать и устанавливать.
# Доступ к определению верхнего и нижнего колонтитула первой страницы осуществляется с помощью свойств Section.first_page_header и Section.first_page_footer соответственно.
{Section.first_page_footer}:
# Свойство Section.first_page_footer представляет собой объект _Footer, определяющий содержимое нижнего колонтитула для первой страницы этого раздела.
# Содержимое нижнего колонтитула для первой страницы раздела игнорируется, если для свойства Section.different_first_page_header_footer=True.
{Section.first_page_header}:
# Свойство Section.first_page_header представляет собой объект _Header, определяющий содержимое верхнего колонтитула для первой страницы этого раздела.
# Содержимое верхнего колонтитула для первой страницы раздела игнорируется, если для свойства Section.different_first_page_header_footer=True.

{Section.even_page_footer}:
# Свойство Section.even_page_footer представляет собой объект _Footer, определяющий содержимое нижнего колонтитула для четных страниц.
# Содержимое нижнего колонтитула для четных страниц игнорируется, если для параметра документа odd_and_even_pages_header_footer=True.
{Section.even_page_header}:
# Свойство Section.even_page_header представляет собой объект _Header, определяющий содержимое верхнего колонтитула для четных страниц.
# Содержимое верхнего колонтитула для четных страниц игнорируется, если для параметра документа .odd_and_even_pages_header_footer=True.

{Section.footer}:
# Свойство Section.footer представляет собой объект _Footer, представляющий нижний колонтитул страницы по умолчанию для этого раздела.
# Нижний колонтитул по умолчанию используется для страниц с нечетными номерами, когда включены отдельные нечетные/четные нижние колонтитулы. 
# В противном случае он используется как для нечетных, так и для четных страниц.
# Обратите внимание, что, как и ячейка документа или таблицы, колонтитул должен содержать минимум один абзац, 
# следовательно новый/пустой заголовок уже содержит один пустой абзац. К этому первому абзацу можно получить доступ 
# как header.paragraphs[0] с целью добавления к нему содержимого. Использование header.add_paragraph() для добавления 
# содержимого приведет к тому, что над только что добавленным абзацем останется пустой (который имеется по умолчанию).

{Колонтитулы имеют свои методы и свойства}:
# footer.add_paragraph(text='', style=None) - добавляет абзац в конец контейнера колонтитула, вставляя текст text за один проход, если он присутствует. 
# Если style=None, то стиль абзаца не применяется, что имеет тот же эффект, что и применение стиля 'Normal'.
# footer.add_table(rows, cols, width) - добавляет таблицу с параметрами переданными аргументам rows, cols, width. Ширина width равномерно распределяется между столбцами cols таблицы.
# footer.is_linked_to_previous* - если в этом колонтитуле используется определение из предыдущего раздела, то возвращается True, в противном случае имеет четкое определение.
#   Присвоение True этому свойству удаляет определение верхнего и нижнего колонтитулов для этого раздела, в результате чего оно наследует соответствующее определение предыдущего раздела.
#   Присвоение значения False приводит к добавлению нового пустого определения для этого раздела, но только в том случае, если определение отсутствует.
# footer.paragraphs* - список, содержащий абзацы в этом контейнере, в порядке их следования. Только для чтения.
# {footer.tables*} - список, содержащий таблицы в этом контейнере, в порядке их следования. Только для чтения.

{Section.footer_distance}:
# Свойство Section.footer_distance объект длины Length, представляющий расстояние от нижнего края страницы 
# до нижнего края нижнего колонтитула. Имеет значение None, если в XML нет настройки.

{Section.gutter}:
# Свойство Section.gutter объект длины Length, представляющий размер желоба страницы в английских метрических единицах для всех страниц 
# в этом разделе. Желоб для страницы - это дополнительный интервал, добавленный к внутреннему краю, чтобы обеспечить ровные поля после привязки страницы.

{Section.header}:
# Свойство Section.header представляет собой объект _Header, представляющий верхний колонтитул страницы по умолчанию для этого раздела.
# Верхний колонтитул по умолчанию используется для страниц с нечетными номерами, если включены отдельные нечетные/четные заголовки. 
# В противном случае он используется как для страниц с нечетными, так и четными номерами.
# Обратите внимание, что, как и ячейка документа или таблицы, колонтитул должен содержать минимум один абзац, следовательно 
# новый/пустой заголовок уже содержит один пустой абзац. К этому первому абзацу можно получить доступ как header.paragraphs[0] 
# с целью добавления к нему содержимого. Использование header.add_paragraph() для добавления содержимого приведет к тому, 
# что над только что добавленным абзацем останется пустой (который имеется по умолчанию).

# {Колонтитулы имеют свои методы и свойства}:
# {header.add_paragraph(text='', style=None)} - добавляет абзац в конец контейнера колонтитула, вставляя текст text за один проход, если он присутствует. Если style=None, то стиль абзаца не применяется, что имеет тот же эффект, что и применение стиля 'Normal'.
# {header.add_table(rows, cols, width)} - добавляет таблицу с параметрами переданными аргументам rows, cols, width. Ширина width равномерно распределяется между столбцами cols таблицы.
# {header.is_linked_to_previous*} - если в этом колонтитуле используется определение из предыдущего раздела, то возвращается True, в противном случае имеет четкое определение.
#   Присвоение True этому свойству удаляет определение верхнего и нижнего колонтитулов для этого раздела, в результате чего оно наследует соответствующее определение предыдущего раздела.
#   Присвоение значения False приводит к добавлению нового пустого определения для этого раздела, но только в том случае, если определение отсутствует.
# {header.paragraphs*} - список, содержащий абзацы в этом контейнере, в порядке их следования. Только для чтения.
# {header.tables*} - список, содержащий таблицы в этом контейнере, в порядке их следования. Только для чтения.

{Section.page_height}:
# Свойство Section.page_height общая высота страницы, используемая для этого раздела, включая все значения расстояния между краями, такие как поля. 
# Принимается во внимание ориентация страницы, поэтому, например, ее ожидаемое значение будет 8,5 дюймов для бумаги формата Letter, при альбомной ориентации.
{Section.page_width}:
# Свойство Section.page_width общая ширина страницы, используемая для этого раздела, включая все значения расстояния между краями, такие как поля. 
# Принимается во внимание ориентация страницы, поэтому, например, ее ожидаемое значение будет 11 дюймов для бумаги формата Letter, при альбомной ориентации.
{Section.right_margin}:
# Свойство Section.right_margin объект длины Length, представляющий правое поле для всех страниц в этом разделе в английских метрических единицах.
{Section.start_type}:
# Свойство Section.start_type представляет собой перечисление WD_SECTION_START, соответствующий поведению начального разрыва этого раздела, 
# например WD_SECTION.ODD_PAGE, если раздел должен начинаться на следующей нечетной странице.
{Section.top_margin}:
# Свойство Section.top_margin объект длины Length, представляющий верхнее поле для всех страниц в этом разделе в английских метрических единицах.
'''

'''# Примеры практического использования объекта Section смотрите в материале "Настройка/изменение макета документа".
# https://docs-python.ru/packages/modul-python-docx-python/izmenenie-maketa-dokumenta/#head-foot'''

# Содержание:
# Настройка/изменение макета листа документа в python-docx;
# Изменение ориентации листа макета в python-docx;
# Использование верхнего и нижнего колонтитулов в python-docx;
# Изменение шрифта, заданного по умолчанию для всего документа DOCX.

'Изменение макета листа документа DOCX.'
# При создании документа с расширением .docx с помощью модуля python-docx, прежде всего, необходимо создать объект документа Document(), 
# с которым и производятся все дальнейшие манипуляции. Так вот, в момент создания экземпляра Document() открывается пустой документ, 
# основанный на "шаблоне по умолчанию", в котором определены: размер листа, ориентация, отступы, колонтитулы и т.д.
# Объект документа .docx имеет свойство Document.sections, которое представляет собой последовательность объектов раздела Section. 
# Каждый объект секции/раздела Section предоставляет доступ к настройкам макета листа этой секции/раздела, а именно, ориентации, отступам, колонтитулам и т.д. этого раздела.
# При создании экземпляра документа Document() открывается пустой документ, у которого Document.sections имеет только одну секцию. 
# Следовательно, для изменения параметров макета листа .docx документа, после его создания, необходимо получить доступ к первой 
# секции и изменить ее свойства. Так как .sections - это последовательность, то доступ к объекту первой секции Section будем осуществляем по индексу (.sections[0]).

from docx import Document
# импортируем единицы измерения
from docx.shared import Mm, Cm
# импортируем необходимые перечисления
from docx.enum.text import WD_ALIGN_PARAGRAPH

# создание экземпляра документа
doc = Document()
# доступ к первой секции:
section = doc.sections[0]
# высота листа в сантиметрах
section.page_height = Cm(29.7)
# ширина листа в сантиметрах
section.page_width = Cm(21.0)
# левое поле в миллиметрах
section.left_margin = Mm(20.4)
# правое поле в миллиметрах
section.right_margin = Mm(10)
# верхнее поле в миллиметрах
section.top_margin = Mm(15)
# нижнее поле в миллиметрах
section.bottom_margin = Mm(10)
# отступ от верхнего края страницы до 
# нижнего края нижнего колонтитула
section.header_distance = Mm(10)
# отступ от нижнего края страницы до 
# нижнего края нижнего колонтитула
section.footer_distance = Mm(10)
# Добавим заголовок - это то же самое что 
# и параграф, только с определенными стилями
head = doc.add_heading('Изменение макета всех страниц первой секции.', level=1)
# выравниваем заголовок по середине
head.alignment = WD_ALIGN_PARAGRAPH.CENTER
# отступ до следующего элемента документа
head.paragraph_format.space_after = Mm(5)
# Добавим параграф
doc.add_paragraph('Доступ к свойствам раздела/секции, таким как поля и ориентация страницы.')
doc.save('test.docx')
# Смотрите справочную информацию по объекту Section, что бы узнать, какие параметры макета страницы еще можно менять.
# Обратите внимание, что изменения свойств секции затронут все страницы в этой секции. Для того, чтобы добавить 
# новую страницу/лист другого размера и/или ориентации в общий документ, необходимо создать новую секцию методом Document.add_section().


'Изменение ориентации листа документа DOCX.'
# Размеры и ориентацию страницы определенной секции/раздела описывают три свойства, это: section.orientation, section.page_width и section.page_height.
# Для изменения ориентации листа секции/раздела с книжной на альбомную и наоборот необходимо задавать их все разом, т.е. недостаточно просто указать section.orientation = WD_ORIENT.LANDSCAPE.
# Смотрим пример:
from docx import Document
# импортируем необходимые перечисления
from docx.enum.text import WD_ALIGN_PARAGRAPH 
from docx.enum.section import WD_SECTION, WD_ORIENT

# создание экземпляра документа
doc = Document()
# добавим заголовок 
head = doc.add_heading('Первая секция документа.', level=1)
# выравниваем заголовок по середине
head.alignment = WD_ALIGN_PARAGRAPH.CENTER
# Добавим новую секцию
doc.add_section(start_type=WD_SECTION.NEW_PAGE)
# доступ ко второй секции и задаем ориентацию
doc.sections[1].orientation = WD_ORIENT.LANDSCAPE
# задаем высоту и ширину, считывая ее 
# с первой секции и инвертируя значения
doc.sections[1].page_width = doc.sections[0].page_height
doc.sections[1].page_height = doc.sections[0].page_width
# добавим заголовок новой секции
head = doc.add_heading('Вторая секция документа.', level=1)
# выравниваем заголовок по середине
head.alignment = WD_ALIGN_PARAGRAPH.CENTER
# для возврата к прежней ориентации страницы 
# необходимо указывать все заново
doc.add_section()
doc.sections[2].orientation = WD_ORIENT.PORTRAIT
doc.sections[2].page_width = doc.sections[0].page_width
doc.sections[2].page_height = doc.sections[0].page_height
head = doc.add_heading('Конец', level=1)
doc.save('test.docx')


'Использование верхнего и нижнего колонтитулов в python-docx.'
# Объект секции/раздела Section, также предоставляет доступ к содержимому верхнего и нижнего колонтитула документа.
# Доступ осуществляется посредствам обращения к соответствующим свойствам секции:
Document.sections[0].header     # - осуществляет доступ к верхнему колонтитулу первого раздела/секции документа.
Document.sections[0].footer     # - осуществляет доступ к нижнему колонтитулу первого раздела/секции документа.
# Так как колонтитулы представляют собой контейнеры с уже добавленным первым параграфом, то добавить текст можно 
# через свойство колонтитула paragraphs[0].add_run('Какой-то текст')
# Пример:
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH

doc = Document() 
# доступ к верхнему колонтитулу
header = doc.sections[0].header.paragraphs[0]
# доступ к нижнему колонтитулу
footer = doc.sections[0].footer.paragraphs[0]
# добавляем верхний колонтитул
header.style.font.size = Pt(8)
header.add_run('Верхний колонтитул')
# выравниваем колонтитул по правому краю
header.alignment = WD_ALIGN_PARAGRAPH.RIGHT
# добавляем нижний колонтитул
footer.style.font.size = Pt(10)
footer.add_run('Нижний колонтитул')
# выравниваем колонтитул по правому краю
footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
# Добавим параграф
doc.add_paragraph('Текст первой страницы.')
doc.add_paragraph('Доступ к верхнему и нижнему колонтитулам.')
# Добавим разрыв страницы
doc.add_page_break()
doc.add_paragraph('Текст второй страницы.')
doc.add_paragraph('Доступ к верхнему и нижнему колонтитулам.')
# теперь прочитаем колонтитулы
text_header = doc.sections[0].header.paragraphs[0].text
print(text_header)
text_footer = doc.sections[0].footer.paragraphs[0].text
print(text_footer)
doc.save("test.docx")


'Изменение шрифта по умолчанию и его размера для документа DOCX.'
# Шрифт документа и его размер по умолчанию для всего документа можно задать, изменив встроенный стиль 'Normal' следующим образом:
from docx import Document
from docx.shared import Mm, Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH 

doc = Document()
# изменяем стиль текста по умолчанию
style = doc.styles['Normal']
# название шрифта по умолчанию
style.font.name = 'Arial'
# размер шрифта по умолчанию
style.font.size = Pt(12)
head = doc.add_heading('Изменение шрифта по умолчанию.', level=1)
# выравниваем заголовок по середине
head.alignment = WD_ALIGN_PARAGRAPH.CENTER
head.style.font.size = Pt(18)
# отступ до следующего элемента документа
head.paragraph_format.space_after = Mm(5)
# Добавим параграф
doc.add_paragraph('Текст параграфа документа.')
doc.save('test.docx')


'''Свойства и методы объекта Paragraph в python-docx.
https://docs-python.ru/packages/modul-python-docx-python/obekt-paragraph/#Paragraph.paragraph_format'''

'''Содержание:
{Paragraph.add_run()} добавляет прогон текста в конец абзаца,
{Paragraph.alignment} выравнивание текста в абзаце,
{Paragraph.clear()} очищает содержимое абзаца,
{Paragraph.insert_paragraph_before()} вставляет новый абзац перед текущем абзацем,
{Paragraph.paragraph_format} доступ к свойствам форматирования абзаца,
{Paragraph.runs} список экземпляров прогонов,
{Paragraph.style} стиль, присвоенный абзацу,
{Paragraph.text} весь текст абзаца.'''

'Paragraph.add_run(text=None, style=None):'
# Метод Paragraph.add_run() добавляет прогон к этому абзацу, содержащий текст text и имеющий стиль символов style, идентифицируемый стилем идентификатора стиля.
# Аргумент style - это встроенный или созданный пользователем стиль в интерфейсе MS Word. Типа Paragraph.style, 
# только тот, который можно применить к символам текста, а не к абзацу целиком. Может быть объектом стиля абзаца Style.
# Аргумент text может содержать символы табуляции \t, которые преобразуются в соответствующую XML-форму, 
# а также может содержать символы новой строки \n или возврата каретки \r, каждый из которых преобразуется в разрыв строки.
# Метод возвращает объект прогона Run, который дает больше контроля над форматированием текста этого прогона (например: выделение цветом, другой шрифт, его размер и т.д.).
# Прогоны в основном используются для пользовательского форматирования текста внутри абзаца. Форматирование на уровне символов, например полужирный и курсив, 
# применяется на уровне прогона paragraph.add_run(). Прогонов в абзаце может быть больше одного. Таким образом, для абзаца с полужирным словом посередине 
# требуется три прогона: обычный, полужирный - содержащий слово, и еще один нормальный для текста после него.
# Смотрим пример:
from docx import Document

doc = Document()
# добавляем пустой параграф
p = doc.add_paragraph()
# формируем абзац прогонами текста
p.add_run('Этот абзац ')
# прогон напишем курсивом
p.add_run('формируется частями').italic = True
p.add_run(', которые добавляются  ')
# этот прогон сделаем жирным
p.add_run('прогонами').bold = True
p.add_run(' с текстом.')
doc.save('test.docx')


'Paragraph.alignment:'
# Свойство Paragraph.alignment - представляет собой перечисление WD_PARAGRAPH_ALIGNMENT, которое определяет настройку выравнивания для этого абзаца.
# Значение None указывает, что абзац не имеет прямого значения выравнивания и унаследует это значение из своей иерархии стилей. 
# Назначение None этому свойству удаляет любое значение выравнивания, которое было указано напрямую.
from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Pt

doc = Document()
# добавляем пустой параграф
p = doc.add_paragraph()
# Выравниваем абзац по середине 
p.alignment = WD_ALIGN_PARAGRAPH.CENTER
run = p.add_run('Заголовок, размером 24 pt.')
# размер шрифта
run.font.size = Pt(24)
run.bold = True
doc.save('test.docx')

'''Настройка форматирования параграфа'''
p = doc.add_paragraph()
p.alignment = WD_ALIGN_PARAGRAPH.RIGHT
run = p.add_run('text')
run.bold = True

'''
{Paragraph.clear()}:
Метод Paragraph.clear() удаляет/очищает все содержимое этого абзаца и возвращает его. При этом сохраняется форматирование на уровне абзаца, такое как стиль.
'''


'''
{Paragraph.insert_paragraph_before(text=None, style=None)}:
Метод Paragraph.insert_paragraph_before() вставляет новый абзац с текстом text и стилем style непосредственно перед абзацем Paragraph. Метод возвращает объект вновь созданного абзаца.
Если аргумент text не пустая строка и не None, то новый абзац будет содержать этот текст, добавленный за один прогон. Если указан стиль style, то этот стиль назначается новому абзацу.
from docx import Document
'''
doc = Document()
# добавляем абзаца
p = doc.add_paragraph('Второй абзац.')
# вставляем новый абзац перед абзацем `p`
prior = p.insert_paragraph_before('Первый абзац.')
# стиль первого абзаца
prior.style = 'Intense Quote'
doc.save('test.docx')
# Метод кажется бессмысленным, но это только первое впечатление. Он помогает при редактировании документа, 
# т.к. позволяет вставить нужный абзац в середину документа!!! Например, можно найти объект того абзаца, 
# перед которым нужно вставить новый при помощи регулярных выражений и дело в шляпе...


'''
{Paragraph.paragraph_format}:
Свойство Paragraph.paragraph_format представляет собой объект ParagraphFormat, который предоставляет 
доступ к свойствам форматирования для этого абзаца, таким как межстрочный интервал, отступ и т. д.'''
from docx import Document
from docx.shared import Mm

doc = Document()
# Добавляем абзац
p = doc.add_paragraph('Новый абзац с отступами и красной строкой.')
# получаем объект форматирования
fmt = p.paragraph_format
# Форматируем:
# добавляем отступ слева
fmt.first_line_indent = Mm(15)
# добавляем отступ до абзаца
fmt.space_before = Mm(20)
# добавляем отступ слева
fmt.space_after = Mm(10)
doc.add_paragraph('Новый абзац.')
doc.add_paragraph('Еще новый абзац.')
doc.save('test.docx')


'''
{Paragraph.runs}:
Свойство Paragraph.runs список экземпляров прогонов Run этого абзаца, которые соответствуют XML-элементам <w:r> в этом параграфе.
Это свойство, например, можно использовать для извлечения текста абзаца не целиком, а по прогонам, или изменения стилей прогонов абзаца...
Например получить текст всех прогонов определенного абзаца, заданного как p, можно как-то так:
'''
runs_txt = []
for run in p.runs:
    runs_txt.append(run.text)
print(''.join(runs_txt))
'''------------------------------------------------'''
'''Цвет текста параграфа'''
paragraph.runs[0].font.color.rgb = RGBColor(255, 0, 0)
'''------------------------------------------------'''

'''
{Paragraph.style}:
# Свойство Paragraph.style представляет собой объект Style, присвоенный этому абзацу. Если абзацу не присвоен явный стиль, то его значением является 
# стиль абзаца по умолчанию для документа. Значение свойства .style можно как считывать, так и присвоить новое.
# Значением Paragraph.style может быть Имя стиля абзаца, которое встроено в интерфейс MS Word.
# Присвоение значения None удаляет любой примененный стиль, делая его эффективное значение стилем абзаца по умолчанию для документа.
# Важно!!! Встроенные стили хранятся в файле WordprocessingML под своим английским именем, например 'Heading 1', и не зависят от локализации MS Word. 
# Так как модуль python-docx работает с файлом WordprocessingML, то поиск стиля должен использовать английское имя. Если файл WordprocessingML 
# не найден (MS Word не установлен, например в OS Linux) то модуль python-docx работает со своей версией этого файла. Что бы создать сопоставление 
# между именами стилей на русском языке и именами на английском языке посетите эту ссылку.
# Пользовательские стили, также известные как настраиваемые стили, не локализованы и доступны по имени, как оно отображается в пользовательском интерфейсе Word.'''
from docx import Document

doc = Document()
# добавляем параграф
p = doc.add_paragraph("Cтиль абзаца 'List Number'.")
# применяем стиль
p.style = 'List Number'
# добавляем параграф и сразу применяем стиль
p = doc.add_paragraph('Встроен в MS Office.').style = 'List Number'
# добавляем параграф, стиль передаем как аргумент
doc.add_paragraph('Cтиль абзаца.', style='List Bullet')
doc.add_paragraph('Обычный список.', style='List Bullet')
doc.save('test.docx')


'Paragraph.text:'
# Свойство Paragraph.text представляет собой строку, сформированную путем объединения текста каждого прогона в абзаце. 
# Табуляции и разрывы строк в XML сопоставляются символам \t и \n соответственно.
# получение текста абзаца
p_text = p.text
print(p_text)

# эквивалентно

runs_txt = []
for run in p.runs:
    runs_txt.append(run.text)
print(''.join(runs_txt))
# Присвоение текста этому свойству приводит к замене всего существующего содержимого абзаца за один прогон Paragraph.add_run().
#  Символ \t в тексте сопоставляется элементу <w:tab/>, а каждый символ \n или \r сопоставляется с разрывом строки. Форматирование
#  на уровне абзаца, такое как стиль абзаца, сохраняется. Форматирование на уровне прогонов (объектов Run), такое как жирный шрифт, 
# курсив или цвет текста прогона, удаляется.



'''Свойства и методы объекта Font в python-docx.
https://docs-python.ru/packages/modul-python-docx-python/obekt-font/'''

# Объект Font используется для стилизации отдельных слов/символов в абзаце документа MS Word. 
# Объект Font не создается вручную, а возвращается в результате вызова свойства Run.font.

from docx import Document
from docx.shared import Pt, RGBColor
from docx.enum.text import WD_UNDERLINE

# создание документа
doc = Document()
# задаем стиль текста по умолчанию
style = doc.styles['Normal']
style.font.name = 'Calibri'
style.font.size = Pt(14)
p = doc.add_paragraph('Пользовательское ')
# добавляем текст прогоном
run = p.add_run('форматирование ')
# Форматируем текст прогона
run.font.size = Pt(16)
run.font.italic = True
# добавляем еще текст прогоном
run = p.add_run('символов текста')
# Форматируем текст прогона
run.font.name = 'Arial'
run.font.size = Pt(18)
run.font.color.rgb = RGBColor(0, 0, 255)
run.font.bold = True
run.font.underline = WD_UNDERLINE.DOUBLE
# прогон без стиля
p.add_run(' в абзаце.')
doc.save('test.docx')

'{{{Описание объекта Run}}}.'
# Объект Font представляет собой прокси-объект, оборачивающий XML элемент <w:rPr> документа MS Word, 
# который предоставляет доступ к свойствам символов, таким как имя шрифта, его размер, цвет, стиль (жирный, курсив) и т.д.
# Некоторые свойства объекта Font принимают три значения:
#   True - соответствуют включению свойства;
#   False - соответствуют выключению свойства;
#   None - означает, что действующее значение свойства берется/наследуется из иерархии стилей документа.
# Объект Font не создается вручную, а предоставляются свойством Run.font.


'''Свойства объекта Run.'''
'''
{Font.all_caps} текст переводится в верхний регистр,
{Font.bold} текст выделяется жирным,
{Font.color} цвет символов текста,
{Font.complex_script} обрабатываются как сложный сценарий,
{Font.cs_bold} символы сценария - жирным шрифтом,
{Font.cs_italic} символы сценария - курсивом,
{Font.double_strike} текст с двойным зачеркиванием,
{Font.emboss} текст рельефно приподнят над страницей,
{Font.hidden} текст будет скрыт от отображения,
{Font.highlight_color} цвет выделения текста,
{Font.imprint текст} вдавлен в страницу,
{Font.italic} текст выделяется курсивом,
{Font.math текст} обрабатывается как математика Office Open XML,
{Font.name} имя шрифта, например 'Arial',
{Font.no_proof} содержимое не сообщает об ошибках орфографии,
{Font.outline} у текста есть контур,
{Font.shadow} у текста есть тень,
{Font.size} высота шрифта,
{Font.small_caps} строчные буквы отображаются на два пункта меньше чем заглавные,
{Font.spec_vanish} данный текст всегда должен вести себя как скрытый,
{Font.strike} текст выглядит зачеркнутым,
{Font.subscript} текст отображается как нижний индекс,
{Font.superscript} текст отображается как верхний индекс,
{Font.underline} текст выглядит подчеркнутым,
{Font.web_hidden} текст скрывается при просмотре документа как веб-страницы.
'''

'''
{Font.all_caps}:
Свойство Font.all_caps - если установлено значение True, то текст в прогоне отображается заглавными буквами. Значение None означает, 
что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.bold}:
Свойство Font.bold - если установлено значение True, то текст в прогоне отображается жирным шрифтом. Значение None означает, 
что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.color}:
Свойство Font.color представляет собой объект ColorFormat, позволяющий получить или установить цвет текста для этого шрифта.
'''
from docx.shared import Pt, RGBColor
run = paragraph.add_run('форматирование ')
run.font.color.rgb = RGBColor(0, 0, 255)
'''
{Font.complex_script}:
Свойство Font.complex_script - если установлено значение True, то символы в прогоне обрабатываются как сложный сценарий независимо от 
их значений Unicode. Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.cs_bold}:
Свойство Font.cs_bold - если установлено значение True, то сложные символы сценария в прогоне отображаются жирным шрифтом. 
Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.cs_italic}:
Свойство Font.cs_italic - если установлено значение True, то сложные символы сценария в прогоне отображаются курсивным шрифтом. 
Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.double_strike}:
Свойство Font.double_strike - если установлено значение True, то текст в прогоне отображается с двойным зачеркиванием. 
Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.emboss}:
Свойство Font.emboss - если установлено значение True, то текст в прогоне будет выглядеть так, как будто он рельефно приподнят 
над страницей. Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.hidden}:
Свойство Font.hidden - если установлено значение True, то текст в прогоне будет скрыт от отображения, если только настройки MS Word 
не заставляют показывать скрытый текст. Свойство можно получить или установить.'''

'''
{Font.highlight_color}:
Свойство Font.highlight_color представляет собой член перечисления WD_COLOR_INDEX, который указывает цвет 
выделения символов текста, или None, если выделение не применяется. Свойство можно получить или установить.
{Font.imprint}:
Свойство Font.imprint - если установлено значение True, то текст в прогоне выглядит так, как будто он вдавлен в страницу. 
Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.italic}:
Свойство Font.italic - если установлено значение True, то текст в прогоне выделяется курсивом. Значение None 
означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.math}:
Свойство Font.math - значение True указывает, что этот прогон содержит WML, который следует обрабатывать так, 
как если бы это была математика Office Open XML. Свойство можно получить или установить.
{Font.name}:
Свойство Font.name возвращает или устанавливает имя шрифта, например 'Arial'. Если соответствующий шрифт НЕ найден, 
то будет использоваться шрифт по умолчанию, заданный для всего документа MS Word. Значение None означает, что действующее значение унаследовано от иерархии стилей.
{Font.no_proof}:
Свойство Font.no_proof - значение True указывает, что содержимое этого прогона не должно сообщать об ошибках при сканировании документа 
на предмет орфографии и грамматики. Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.outline}:
Свойство Font.outline - если установлено значение True, то символы в прогоне выглядят так, как будто у них есть контур, 
путем рисования границы шириной в один пиксель вокруг внутренней и внешней границ каждого глифа символа. Свойство можно 
получить или установить. Значение None означает, что действующее значение унаследовано от иерархии стилей.
{Font.shadow}:
Свойство Font.shadow - значение True приводит к тому, что текст в прогоне отображается так, как будто у каждого символа есть тень. 
Свойство можно получить или установить. Значение None означает, что действующее значение унаследовано от иерархии стилей.
{Font.size}:
Свойство Font.size представляет собой значение Length или None, указывающее высоту шрифта в английских метрических единицах (EMU). 
Значение None означает, что размер шрифта должен быть унаследован от иерархии стилей. Свойство можно получить или установить.
Объект Length - это подкласс int, обладающий свойствами для удобного преобразования величин в пункты Pt или другие единицы длины.
'''
# font.size = Pt(24)
# font.size
# 304800
# font.size.pt
# 24.0

'''
{Font.small_caps}:
Свойство Font.small_caps - если установлено значение True, то строчные символы в прогоне отображаются 
как заглавные буквы на два пункта меньше, чем размер шрифта, указанный для цикла. Значение None означает, 
что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.spec_vanish}:
Свойство Font.spec_vanish - значение True указывает, что данный прогон всегда должен вести себя так, 
как если бы он был скрыт, даже если в текущем документе отображается скрытый текст. Свойство имеет очень узкое, 
специализированное назначение, связанное с оглавлением документа. Свойство можно получить или установить.
'''

'''
{Font.strike}:
Свойство Font.strike - если установлено значение True, то текст в прогоне будет выглядеть зачеркнутым. Значение None означает, 
что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.subscript}:
Свойство Font.subscript - если установлено значение True, то символы прогона отображаются как нижний индекс. Значение 
None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
{Font.superscript}:
Свойство Font.superscript - если установлено значение True, то символы прогона отображаются как верхний индекс. 
Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
'''

'''
{Font.underline}:
Свойство Font.underline может принимать None, True, False или значение из {WD_UNDERLINE}.
None - указывает на то, что прогон наследует значение подчеркивания содержащего абзаца, при этом удаляет все напрямую применяемые значения подчеркивания.
False - указывает на настройку прогона без подчеркивания, переопределяющую любое унаследованное значение.
True - указывает одинарное подчеркивание.
WD_UNDERLINE используются для определения других стилей подчеркивания, таких как двойное, волнистое и пунктирное и т.д.
{Font.web_hidden}:
Свойство Font.web_hidden - значение True указывает, что содержимое этого прогона должно быть скрыто при отображении документа в виде веб-страницы. Значение None означает, что действующее значение унаследовано от иерархии стилей. Свойство можно получить или установить.
'''

'''
{WD_UNDERLINE}:
Перечисление WD_UNDERLINE задает стиль подчеркивания, которое применяется к серии символов/слов текста.
{WD_UNDERLINE.NONE} - без подчеркивания. Этот параметр отменяет любое унаследованное значение подчеркивания, поэтому может использоваться для удаления подчеркивания из серии, которая наследует подчеркивание из содержащего его абзаца. Обратите внимание, что это не то же самое, что присвоение None для Run.underline. Значение None, допустимо для присваивания, но заставляет прогон наследовать значение подчеркивания. Назначение WD_UNDERLINE.NONE приводит к безоговорочному отключению подчеркивания.
{WD_UNDERLINE.SINGLE} - подчеркивание одной линией. Обратите внимание, что этот параметр доступен только для присваивания в том смысле, что для прогона с этим параметром возвращается True (а не значение в виде WD_UNDERLINE.SINGLE).
{WD_UNDERLINE.WORDS} - подчеркивает только слова (т.е. не подчеркивает пробелы между словами).
{WD_UNDERLINE.DOUBLE} - подчеркивание двойной линией.
{WD_UNDERLINE.DOTTED} - подчеркивание точками.
{WD_UNDERLINE.THICK} - подчеркивание одной толстой линией.
{WD_UNDERLINE.DASH} - подчеркивание пунктирной линией.
{WD_UNDERLINE.DOT_DASH} - подчеркивание чередующимся точки и тире.
{WD_UNDERLINE.DOT_DOT_DASH} - подчеркивание точка-точка-тире.
{WD_UNDERLINE.WAVY} - подчеркивание одной волнистой линией.
{WD_UNDERLINE.DOTTED_HEAVY} - подчеркивание жирными точками
{WD_UNDERLINE.DASH_HEAVY} - подчеркивание жирной пунктирной линией.
{WD_UNDERLINE.DOT_DASH_HEAVY} - чередующиеся жирные точки и жирные тире.
{WD_UNDERLINE.DOT_DOT_DASH_HEAVY} - чередующиеся жирные точка-точка-тире.
{WD_UNDERLINE.WAVY_HEAVY} - жирная волнистая линия.
{WD_UNDERLINE.DASH_LONG} - длинные пунктирные линии.
{WD_UNDERLINE.WAVY_DOUBLE} - двойная волнистая линия.
{WD_UNDERLINE.DASH_LONG_HEAVY} - длинные жирные пунктирные линии.
'''
import docx
from docx.enum.text import WD_UNDERLINE

doc = docx.Document()
p = doc.add_paragraph()
p.add_run('Подчеркивает только слова.\n').underline = WD_UNDERLINE.WORDS
p.add_run('Подчеркивает точками.\n').underline = WD_UNDERLINE.DOTTED
p.add_run('Подчеркивает двойной линией.\n').underline = WD_UNDERLINE.DOUBLE
p.add_run('Подчеркивает волнистой линией.').underline = WD_UNDERLINE.WAVY
doc.save('test.docx')


'''Встроенные константы модуля python-docx.
https://docs-python.ru/packages/modul-python-docx-python/konstanty-modulja-docx/#WD_ROW_HEIGHT_RULE'''

'''Содержание:
{WD_SECTION_START} тип начала разрыва секции/раздела;
{WD_ORIENTATION} ориентация листа/страницы документа;
{WD_ALIGN_PARAGRAPH} выравнивание текста в абзаце;
{WD_LINE_SPACING} интерпретация межстрочного интервала абзаца.
{WD_UNDERLINE} задает стиль подчеркивания символа/слова;
{WD_COLOR_INDEX} задает стандартный цвет выделения шрифтов.
{WD_TABLE_ALIGNMENT} тип выравнивания таблицы.
{WD_ROW_HEIGHT_RULE} правило определения высоты строки таблицы.
{WD_CELL_VERTICAL_ALIGNMENT} вертикальное выравнивание текста в одной или нескольких ячейках таблицы;
{WD_STYLE_TYPE} типы стиля: абзац, символ, список или таблица.'''


'''
{WD_SECTION_START}:
Короткая ссылка для импорта WD_SECTION - это перечисление, которое задает тип начала разрыва секции.
{WD_SECTION.CONTINUOUS}: непрерывный разрыв секции.
{WD_SECTION.NEW_COLUMN}: секция начинается с нового столбца.
{WD_SECTION.NEW_PAGE}: секция начинается с новой страницы.
{WD_SECTION.EVEN_PAGE}: секция начинается на следующей четной страницы.
{WD_SECTION.ODD_PAGE}: секция начинается на следующей нечетной странице.
Пример:
'''
from docx.enum.section import WD_SECTION

section = document.sections[0]
section.start_type = WD_SECTION.NEW_PAGE


'''
{WD_ORIENTATION}:
Короткая ссылка для импорта WD_ORIENT - это перечисление, которое задает ориентацию макета страницы.
{WD_ORIENT.PORTRAIT}: Книжная ориентация.
{WD_ORIENT.LANDSCAPE}: Альбомная ориентация.
Пример:
'''
from docx.enum.section import WD_ORIENT

section = document.sections[-1]
section.orientation = WD_ORIENT.LANDSCAPE

'''
WD_PARAGRAPH_ALIGNMENT:
Короткая ссылка для импорта WD_ALIGN_PARAGRAPH - это перечисление, которое задает тип выравнивание всего текста в абзаце/параграфе.
{WD_ALIGN_PARAGRAPH.LEFT} - по левому краю;
{WD_ALIGN_PARAGRAPH.CENTER} - по центру;
{WD_ALIGN_PARAGRAPH.RIGHT} - по правому краю;
{WD_ALIGN_PARAGRAPH.JUSTIFY} - по ширине;
{WD_ALIGN_PARAGRAPH.DISTRIBUTE} - символы распределяются так, чтобы заполнить всю ширину абзаца;
{WD_ALIGN_PARAGRAPH.JUSTIFY_MED} - оправдано со средней степенью сжатия символов;
{WD_ALIGN_PARAGRAPH.JUSTIFY_HI} - оправдано высокой степенью сжатия символов;
{WD_ALIGN_PARAGRAPH.JUSTIFY_LOW} - оправдано с низким коэффициентом сжатия символов.
Пример:
'''
from docx.enum.text import WD_ALIGN_PARAGRAPH

paragraph = document.add_paragraph()
paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER


'''
{WD_LINE_SPACING}:
Перечисление {WD_LINE_SPACING} задает формат межстрочного интервала, применяемый к объекту форматирования абзаца 
{ParagraphFormat.line_spacing_rule}.
Устанавливаемые значения:
{WD_LINE_SPACING.ONE_POINT_FIVE} - Space-and-a-half line spacing.
{WD_LINE_SPACING.AT_LEAST} - межстрочный интервал всегда должен быть не менее указанного значения;
{WD_LINE_SPACING.DOUBLE} - двойной межстрочный интервал;
{WD_LINE_SPACING.EXACTLY} - межстрочный интервал - это точно указанная величина;
{WD_LINE_SPACING.MULTIPLE} - межстрочный интервал указывается как кратный высоте строки. Изменение размера шрифта пропорционально изменит межстрочный интервал;
{WD_LINE_SPACING.SINGLE} - одинарный межстрочный интервал (по умолчанию).
Пример:
'''
from docx.enum.text import WD_LINE_SPACING

paragraph = document.add_paragraph()
paragraph.paragraph_format.line_spacing_rule = WD_LINE_SPACING.EXACTLY


'''
{WD_UNDERLINE}:
Перечисление {WD_UNDERLINE} задает стиль подчеркивания, которое применяется к серии символов/слов текста.
Устанавливаемые значения:
{WD_UNDERLINE.NONE} - без подчеркивания. Этот параметр отменяет любое унаследованное значение подчеркивания, поэтому может использоваться для удаления подчеркивания из серии, которая наследует подчеркивание из содержащего его абзаца. Обратите внимание, что это не то же самое, что присвоение None для Run.underline. Значение None, допустимо для присваивания, но заставляет прогон наследовать значение подчеркивания. Назначение WD_UNDERLINE.NONE приводит к безоговорочному отключению подчеркивания.
{WD_UNDERLINE.SINGLE} - подчеркивание одной линией. Обратите внимание, что этот параметр доступен только для присваивания в том смысле, что для прогона с этим параметром возвращается True (а не значение в виде WD_UNDERLINE.SINGLE).
{WD_UNDERLINE.WORDS} - подчеркивает только слова (т.е. не подчеркивает пробелы между словами).
{WD_UNDERLINE.DOUBLE} - подчеркивание двойной линией.
{WD_UNDERLINE.DOTTED} - подчеркивание точками.
{WD_UNDERLINE.THICK} - подчеркивание одной толстой линией.
{WD_UNDERLINE.DASH} - подчеркивание пунктирной линией.
{WD_UNDERLINE.DOT_DASH} - подчеркивание чередующимся точки и тире.
{WD_UNDERLINE.DOT_DOT_DASH} - подчеркивание точка-точка-тире.
{WD_UNDERLINE.WAVY} - подчеркивание одной волнистой линией.
{WD_UNDERLINE.DOTTED_HEAVY} - подчеркивание жирными точками
{WD_UNDERLINE.DASH_HEAVY} - подчеркивание жирной пунктирной линией.
{WD_UNDERLINE.DOT_DASH_HEAVY} - чередующиеся жирные точки и жирные тире.
{WD_UNDERLINE.DOT_DOT_DASH_HEAVY} - чередующиеся жирные точка-точка-тире.
{WD_UNDERLINE.WAVY_HEAVY} - жирная волнистая линия.
{WD_UNDERLINE.DASH_LONG} - длинные пунктирные линии.
{WD_UNDERLINE.WAVY_DOUBLE} - двойная волнистая линия.
{WD_UNDERLINE.DASH_LONG_HEAVY} - длинные жирные пунктирные линии.
Смотрим пример:
'''
import docx
from docx.enum.text import WD_UNDERLINE

doc = docx.Document()
p = doc.add_paragraph()
p.add_run('Подчеркивает только слова.\n').underline = WD_UNDERLINE.WORDS
p.add_run('Подчеркивает точками.\n').underline = WD_UNDERLINE.DOTTED
p.add_run('Подчеркивает двойной линией.\n').underline = WD_UNDERLINE.DOUBLE
p.add_run('Подчеркивает волнистой линией.').underline = WD_UNDERLINE.WAVY
doc.save('test.docx')


'''
{WD_COLOR_INDEX}:
Перечисление {WD_COLOR_INDEX} задает применяемый стандартный предустановленный цвет в MS Word. Используется для выделения шрифтов и, возможно, других объектов.
Устанавливаемые значения:
{WD_COLOR_INDEX.AUTO} - Автоматический цвет. По умолчанию, обычно черный.
{WD_COLOR_INDEX.BLACK} - Черный цвет.
{WD_COLOR_INDEX.BLUE} - Синий цвет
{WD_COLOR_INDEX.BRIGHT_GREEN} - Ярко-зеленый цвет.
{WD_COLOR_INDEX.DARK_BLUE} - Цвет темно-синий.
{WD_COLOR_INDEX.DARK_RED} - Темно-красный цвет.
{WD_COLOR_INDEX.DARK_YELLOW} - Темно-желтый цвет.
{WD_COLOR_INDEX.GRAY_25} - 25% серого цвета.
{WD_COLOR_INDEX.GRAY_50} - 50% серого цвета.
{WD_COLOR_INDEX.GREEN} - Зеленый цвет.
{WD_COLOR_INDEX.PINK} - Розовый цвет.
{WD_COLOR_INDEX.RED} - Красный цвет.
{WD_COLOR_INDEX.TEAL} -
{WD_COLOR_INDEX.TURQUOISE} - Бирюзовый цвет.
{WD_COLOR_INDEX.VIOLET} - Фиолетовый цвет.
{WD_COLOR_INDEX.WHITE} - Белый цвет.
{WD_COLOR_INDEX.YELLOW} - Желтый цвет.
Пример:
'''
import docx
from docx.enum.text import WD_COLOR_INDEX

doc = docx.Document()
p = doc.add_paragraph()
p.add_run('Выделение ')
p.add_run('текста').font.highlight_color = WD_COLOR_INDEX.YELLOW
p.add_run(' цветом.')
doc.save('test.docx')


'''
{WD_TABLE_ALIGNMENT}:
Перечисление {WD_TABLE_ALIGNMENT} задает тип выравнивания таблицы.
{WD_TABLE_ALIGNMENT.LEFT}: По левому краю.
{WD_TABLE_ALIGNMENT.CENTER}: По центру.
{WD_TABLE_ALIGNMENT.RIGHT}: По правому краю.
Пример:
'''
from docx.enum.table import WD_TABLE_ALIGNMENT

table = document.add_table(3, 3)
table.alignment = WD_TABLE_ALIGNMENT.CENTER


'''
{WD_ROW_HEIGHT_RULE}:
Короткая ссылка для импорта {WD_ROW_HEIGHT}, задает правило определения высоты строки таблицы.
{WD_ROW_HEIGHT.AUTO}: Высота строки настраивается таким образом, чтобы соответствовать самому высокому значению в строке.
{WD_ROW_HEIGHT.AT_LEAST}: Высота строки должна быть не менее минимального заданного значения.
{WD_ROW_HEIGHT.EXACTLY}: Высота строки - это точное значение.
Пример:
'''
from docx.enum.table import WD_ROW_HEIGHT

table = document.add_table(3, 3)
table.rows[0].height_rule = WD_ROW_HEIGHT.EXACTLY


'''
{WD_CELL_VERTICAL_ALIGNMENT}:
Короткая ссылка для импорта {WD_ALIGN_VERTICAL} задает вертикальное выравнивание текста в одной или нескольких ячейках таблицы.
{WD_ALIGN_VERTICAL.TOP}: Текст выровнен по верхней границе ячейки.
{WD_ALIGN_VERTICAL.CENTER}: Текст выровнен по центру ячейки.
{WD_ALIGN_VERTICAL.BOTTOM}: Текст выравнивается по нижней границе ячейки.
{WD_ALIGN_VERTICAL.BOTH}: Это спецификация OpenXML, но не в самого MS Word. Неясно, какое поведение вызывает этот параметр. Если узнаете, пожалуйста, сообщите нам об этом, и мы обновим документацию. В противном случае, лучше избегать этого варианта.
Пример:
'''
from docx.enum.table import WD_ALIGN_VERTICAL

table = document.add_table(3, 3)
table.cell(0, 0).vertical_alignment = WD_ALIGN_VERTICAL.BOTTOM


'''
{WD_STYLE_TYPE}:
Перечисление {WD_STYLE_TYPE} задает один из четырех типов стиля: абзац, символ, список или таблица..
CHARACTERCharacter style.LISTList style.PARAGRAPHParagraph style.TABLETable style.
{WD_STYLE_TYPE.CHARACTER}: Стиль слова/символа.
{WD_STYLE_TYPE.LIST}: Стиль списка.
{WD_STYLE_TYPE.PARAGRAPH}: Стиль абзаца/параграфа.
{WD_STYLE_TYPE.TABLE}: Стиль таблицы.
Пример:
'''
from docx import Document
from docx.enum.style import WD_STYLE_TYPE

styles = Document().styles
assert styles[0].type == WD_STYLE_TYPE.PARAGRAPH

'''Свойства документа'''
from rich import inspect
inspect(doc.core_properties)
# print(doc.core_properties.__dir__())

'''Свайства файла'''
document_property = doc.core_properties
print(dir(document_property))
print([p for p in dir(document_property) if not p.startswith('_')])

'''------------------------------------------------'''
def delete_paragraph(paragraph):
    '''Удаление параграффа и таблицы'''
    p = paragraph._element
    p.getparent().remove(p)
    # paragraph._p = paragraph._element = None

delete_paragraph(doc.paragraphs[-2])
delete_paragraph(doc.tables[1])    
'''------------------------------------------------'''

'''------------------------------------------------'''
'''Копируем элемент с глубокой степенью '''
from copy import deepcopy
paragraph._p.addnext(deepcopy(doc.tables[1]._element))
paragraph._p.addnext(deepcopy(doc.paragraphs[15]._element))

# или

doc = Document('test.docx')
doc_new = Document('test_none.docx')
def copy_elem(paragraph, elem):
    paragraph._p.addnext(deepcopy(elem._element))
ListImport = [
    doc.paragraphs[15],
    table,
    doc.paragraphs[14],
    doc.paragraphs[13]    
]
paragraph = doc_new.paragraphs[-2]
for i in ListImport: copy_elem(paragraph, i)
'''------------------------------------------------'''
'''Замена текста''' 
for paragraph in doc.paragraphs:
    paragraph.text = paragraph.text.replace("old", "new")
'''------------------------------------------------'''
'''Прочитать все параграфы'''
for i, val in enumerate(doc.paragraphs): print(i, val.text)
'''------------------------------------------------'''

def testprog(doc, NameFaileDoc):
    """Создаем COM объект Word для просмотра результата"""
    import win32com.client, os
    pattern_time = 'pattern_time.docx'

    Word = win32com.client.Dispatch("Word.Application")
    Word.Visible = 1
    Word.DisplayAlerts = 0
    for Docum in Word.Documents:
        if Docum.Name == NameFaileDoc or Docum.Name == pattern_time:
            Docum.Close()

    doc.save(NameFaileDoc)
    Word.Documents.Open(os.getcwd() + f"\\{NameFaileDoc}")

# testprog(doc, NameFaileDoc)


'''------------------------------------------------'''
'''Заменяем текст в каждом прогоне каждого параграфа'''
def replaceItem(run, key, resp, bold=None):
    '''Читаем параграф и заменяем текст'''
    run.text = run.text.replace(key, resp[key])

paragraphs = doc.paragraphs
# перебираем все параграфы
for paragraph in paragraphs:
    # перебираем все прогоны в параграфе
    for run in paragraph.runs:
        # Для каждого респонса
        for respo in [data_contract, data_act]:
            # для каждого ключа респонса
            for key in respo:
                # сверяем сходится ли ключ с текстом в параграфе
                if key in run.text:
                    replaceItem(run, key, respo)
'''------------------------------------------------'''
# печатаем текст во всех параграфах по всем прогонам
for paragraph in doc.paragraphs:
    print([run.text for run in paragraph.runs])
'''------------------------------------------------'''